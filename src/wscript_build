import os

obj = bld.new_task_gen('cxx', 'shlib', 'node_addon')
obj.target = 'dns_sd'
obj.uselib = 'DNS_SD'
if bld.env.HAVE_DNSSERVICEGETADDRINFO:
  obj.defines = ['HAVE_DNSSERVICEGETADDRINFO']
obj.includes = ['..']
obj.cxxflags = ['-Wall']
# HACK: The current node master builds a i386 binary while older releases used
# the compilers default x86_64. node-waf still targets x86_64 resulting in an
# incompatible binary. Building the add-on as a universal binary for both
# architectures solves this for now ...
if obj.env.DEST_OS == 'darwin':
  universal_flags = ['-arch', 'i386', '-arch', 'x86_64']
  obj.env.append_value('CXXFLAGS', universal_flags)
  obj.env.append_value('LINKFLAGS_MACBUNDLE', universal_flags)
obj.source = [ 'dns_sd.cpp'
             , 'dns_service_browse.cpp'
             , 'dns_service_enumerate_domains.cpp'
             , 'dns_service_process_result.cpp'
             , 'dns_service_ref.cpp'
             , 'dns_service_ref_deallocate.cpp'
             , 'dns_service_ref_sock_fd.cpp'
             , 'dns_service_register.cpp'
             , 'dns_service_resolve.cpp'
             , 'dns_service_get_addr_info.cpp'
             , 'mdns_utils.cpp'
             , 'txt_record_ref.cpp'
             , 'txt_record_create.cpp'
             , 'txt_record_deallocate.cpp'
             , 'txt_record_get_count.cpp'
             , 'txt_record_set_value.cpp'
             , 'txt_record_get_length.cpp'
             , 'txt_record_buffer_to_object.cpp'
             ]

def post_build(ctx):
  target = obj.env['shlib_PATTERN'] % obj.target
  symlink_path = os.path.join('lib', target)
  if os.path.lexists(symlink_path):
    os.unlink(symlink_path)
  path_to_addon = os.path.join('..', 'build', ctx.path.bld_dir(ctx.env), 'src',
          target)
  os.symlink(path_to_addon, symlink_path)


bld.add_post_fun(post_build)

# vim: set filetype=python :
