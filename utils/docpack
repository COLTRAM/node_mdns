#!/usr/bin/env node

// docpack - documentation for take-away
// disgusting ... but works for now ...

var path   = require('path')
  , fs     = require('fs')
  , child_process = require('child_process')
  , slide  = require('slide')
  , mkdirp = require('mkdirp')
  , glob   = require('glob')
  , ejs    = require('ejs')
  , less   = require('less')
  , ncp    = require('ncp').ncp
  , j      = path.join
  , chain  = slide.chain
  ;

var rootd = path.dirname(process.argv[1]) + '/..'
  , docd  = rootd + '/doc'
  , outd  = rootd + '/out'
  , package = JSON.parse(fs.readFileSync(rootd + '/package.json'))
  , layout = fs.readFileSync(docd + '/layout.ejs').toString()
  ;

var ejs2textile = compilerSync(render_ejs)
  , ejs2html    = compiler(render_page)
  , less2css    = compiler(less.render)
  ;

var prepare = [ [ mkdirp, outd + '/pages']
              ]
  , tasks   = [ [ ejs2textile, docd + '/README.ejs', rootd + '/README.ttt']
              , [ render_pages, docd + '/pages/*.ejs']
              , [ render_stylesheets, docd + '/pages/stylesheets/*.less']
              , [ ncp, docd + '/pages/images', outd + '/pages/images']
              , [ ncp, docd + '/pages/scripts', outd + '/pages/scripts']
              ]
              ;

chain( [ [ run_all, prepare]
       , [ run_all, tasks]
       ]
     , function(error) { console.log('========= done =========') }
     );



function render_pages(pattern, cb) {
  glob(pattern, function(error, files) {
    var tasks = files.map(function(f) { 
      var dst = outd + '/pages/' + path.basename(path.basename(f), '.ejs')
          + '.html';
      return [ejs2html, f, dst] 
    });
    run_all(tasks, cb);
  });
}

function render_stylesheets(pattern, cb) {
  glob(pattern, function(error, files) {
    var tasks = files.map(function(f) { 
      var dst = outd + '/pages/stylesheets/'
          + path.basename(path.basename(f), '.less') + '.css';
      return [less2css, f, dst] 
    });
    run_all(tasks, cb);
  });
}

function render_ejs(source) {
  return ejs.render(source, {package: package});
}

function render_page(source, cb) {
  var metadata = {};
  function meta(k, v) {
    metadata[k] = v;
  }
  function layout_page(error, html) {
    metadata.body = html;
    cb(error, ejs.render(layout, metadata))
  }
  var locals = {package: package, meta: meta};
  piped_comand('redcloth', ejs.render(source, locals), layout_page);
}

function copydir(src, dst, cb) {
}

function piped_comand(comand, input, args, cb) {
  if ( ! cb ) {
    cb = args;
    args = undefined;
  }
  var cmd = child_process.spawn(comand, args)
    , out = ''
    ;
  cmd.stdout.on('data', function(chunk) { out += chunk })
  cmd.stderr.on('data', function(chunk) { console.log(chunk)})
  cmd.on('exit', function(code) {
    if (code) {
      cb(new Error("command '" + command + "' exited with code " + code))
    } else {
      cb(null, out)
    }
  });
  cmd.stdin.write(input);
  cmd.stdin.destroySoon();
  
}

function compilerSync(f) {
  return function(src, dst, cb) {
    fs.readFile(src, function(error, data) {
      if (error) return cb(error);
      var result = f('' + data);
      mkdir_and_write_file(dst, result, cb);
    });
  }
}

function compiler(f) {
  return function(src, dst, cb) {
    fs.readFile(src, function(error, data) {
      if (error) return cb(error);
      f('' + data, function(error, result) {
        if (error) {
          cb(error);
        } else {
          mkdir_and_write_file(dst, result, cb);
        }
      });
    });
  }
}


function run_all(tasks, cb) {
  var done_count = 0, first_error;
  function on_done(error) {
    if (error) {
      first_error = error;
      cb(error);
    }
    if ( ! first_error && ++done_count === tasks.length) cb();
  }
  tasks.forEach(function(t) {
    var f = t.shift();
    t.push(on_done)
    f.apply(null, t);
  });
}

function mkdir_and_write_file(file, content, cb) {
  mkdirp(path.dirname(file), function(error) {
    if (error) {
      cb(error)
    } else {
      fs.writeFile(file, content, cb)
    }
  });
}
// vim: filetype=javascript :
